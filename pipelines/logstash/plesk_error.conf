input {
  beats {
    port => 5044
    tags => ["input_beats"]
  }
}

filter {
  # Parsing initial avec grok (structure de base)
  grok {
    match => {
      "message" => '\[%{DAY:day} %{MONTH:month} %{MONTHDAY:monthday} %{TIME:time} %{YEAR:year}\] \[%{LOGLEVEL:log.level}\] \[client %{IP:source.ip}\] %{GREEDYDATA:error.raw_message}'
    }
    tag_on_failure => ["_grokparsefailure_raw"]
  }

  # Construction du timestamp ISO8601
  mutate {
    add_field => {
      "timestamp_str" => "%{day} %{month} %{monthday} %{time} %{year}"
    }
  }
  date {
    match => ["timestamp_str", "EEE MMM dd HH:mm:ss yyyy"]
    target => "@timestamp"
    locale => "en"
    timezone => "UTC"
  }

  # Nettoyage des champs intermédiaires
  mutate {
    remove_field => ["day", "month", "monthday", "time", "year", "timestamp_str"]
  }

  ### ENRICHISSEMENT DES ERREURS SPECIFIQUES ###

  # 1. Kernel Panic
  if [error.raw_message] =~ /Kernel panic/ {
    mutate {
      add_field => {
        "error.type" => "kernel_panic"
        "event.severity" => "critical"
        "event.category" => "host"
      }
    }
    grok {
      match => {
        "error.raw_message" => "Kernel panic - not syncing: %{GREEDYDATA:error.details}"
      }
    }
  }

  # 2. Tentatives d'intrusion
  else if [error.raw_message] =~ /Unauthorized access attempt/ {
    mutate {
      add_field => {
        "error.type" => "unauthorized_access"
        "event.severity" => "high"
        "event.category" => "authentication"
      }
    }
    grok {
      match => {
        "error.raw_message" => "Unauthorized access attempt detected from IP %{IP:threat.ip}"
      }
    }
  }

  # 3. Erreurs PHP (Database)
  else if [error.raw_message] =~ /PHP Fatal error/ {
    mutate {
      add_field => {
        "error.type" => "php_fatal"
        "event.severity" => "high"
        "event.category" => "application"
      }
    }
    grok {
      match => {
        "error.raw_message" => "PHP Fatal error: %{GREEDYDATA:error.details}"
      }
    }

    # Extraction spécifique pour les erreurs DB
    if [error.details] =~ /Database connection failed/ {
      mutate {
        replace => { "error.type" => "database_connection_failure" }
        add_field => { "service.name" => "mysql" }
      }
    }
  }

  # 4. Erreurs de permission
  else if [error.raw_message] =~ /Permission denied/ {
    mutate {
      add_field => {
        "error.type" => "permission_denied"
        "event.severity" => "medium"
        "event.category" => "file"
      }
    }
    grok {
      match => {
        "error.raw_message" => "Permission denied: %{GREEDYDATA:error.details}"
      }
    }
    # Extraction du chemin fichier
    if [error.details] =~ /Could not open (.+)/ {
      mutate {
        add_field => { "file.path" => "%{[error.details][1]}" }
      }
    }
  }

  # 5. Tentatives SQL Injection
  else if [error.raw_message] =~ /SQL Injection attempt/ {
    mutate {
      add_field => {
        "error.type" => "sql_injection_attempt"
        "event.severity" => "critical"
        "event.category" => "intrusion_detection"
      }
    }
    grok {
      match => {
        "error.raw_message" => "Warning: SQL Injection attempt blocked for user '%{DATA:db.user}'"
      }
    }
  }

  # 6. Erreurs Plesk (Authentification)
  else if [error.raw_message] =~ /PleskException/ {
    mutate {
      add_field => {
        "error.type" => "plesk_auth_failure"
        "event.severity" => "high"
        "event.category" => "authentication"
      }
    }
    grok {
      match => {
        "error.raw_message" => "PleskException: Invalid credentials for user '%{DATA:user.name}'"
      }
    }
  }

  # Normalisation finale ECS
  mutate {
    rename => {
      "error.raw_message" => "message"
    }
    add_field => {
      "log.origin.file.path" => "%{[log][file][path]}"
    }
    remove_field => ["log.original"] # Optionnel
  }

  # Ajout d'un fingerprint pour détecter les doublons
  fingerprint {
    source => ["@timestamp", "source.ip", "message"]
    target => "[@metadata][fingerprint]"
    method => "SHA1"
    key => "logstash_salt"
    concatenate_sources => true
  }
}

output {
  elasticsearch {
    hosts => ["http://192.168.56.101:9200"]
    index => "plesk-error-%{+YYYY.MM.dd}"
    document_id => "%{[@metadata][fingerprint]}"
  }

  # Backup local pour debug
  if "_grokparsefailure_raw" in [tags] {
    file {
      path => "/var/log/logstash/plesk_parse_failures.log"
      codec => line { format => "FAILED TO PARSE: %{message}" }
    }
  }
}
