input {
  beats {
    port => 5044
  }
}

filter {
  # Parsing CSV
  csv {
    separator => ","
    skip_header => "true"
    columns => [
      "timestamp", "event_id", "logon_type", "username", "domain",
      "source_ip", "hostname", "log_level", "log_type", "message"
    ]
  }

  # Conversion des types
  mutate {
    convert => {
      "event_id" => "integer"
      "logon_type" => "integer"
    }
  }

  # Parsing du timestamp
  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
  }

  # Traduction du logon_type en texte comprÃ©hensible
  translate {
    field => "logon_type"
    destination => "event.logon_type_description"
    dictionary => {
      "0" => "System"
      "2" => "Interactive (Console)"
      "3" => "Network (Remote)"
      "4" => "Batch (Scheduled Task)"
      "5" => "Service"
      "7" => "Unlock (Screen)"
      "8" => "NetworkCleartext"
      "9" => "NewCredentials"
      "10" => "RemoteInteractive (RDP)"
      "11" => "CachedInteractive"
    }
    override => true
  }

  # Normalisation des noms de champs selon ECS
  mutate {
    rename => {
      "source_ip"   => "source.ip"
      "hostname"    => "host.name"
      "username"    => "user.name"
      "domain"      => "user.domain"
      "log_level"   => "log.level"
      "log_type"    => "event.category"
    }

    # Ajout de champs ECS standards
    add_field => {
      "event.kind" => "event"
      "event.module" => "active_directory"
      "event.dataset" => "windows.security"
      "event.outcome" => "%{[log.level]}"  
    }
  }

  # Nettoyage de champs inutiles
  mutate {
    remove_field => [
      "host", "path", "timestamp", "@version",
      "agent.ephemeral_id", "agent.type", "input.type"
    ]
  }
}

output {
  stdout { codec => rubydebug }

  elasticsearch {
    hosts => ["http://192.168.56.101:9200"]
    index => "ad-logs"
  }
}
