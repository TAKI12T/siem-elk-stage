input {
  beats {
    port => 5044
  }
}

filter {
  if [log][file][path] =~ /fortimail/ {
    mutate {
      add_tag => ["fortimail"]
    }
  }

  if "fortimail" in [tags] {

    # Nettoyage prÃ©fixe syslog Ã©ventuel
    grok {
      match => {
        "message" => ".*?<%{NUMBER:syslog_pri}>%{GREEDYDATA:fortimail_message}"
      }
      overwrite => ["message"]
      tag_on_failure => []
    }

    # Extraction des paires clÃ©=valeur
    kv {
      source => "fortimail_message"
      field_split => ","
      value_split => "="
      trim_key => "\""
      trim_value => "\""
      target => "fortimail"
    }

    # Construction de la date
    mutate {
      add_field => {
        "fortimail_date" => "%{[fortimail][date]}"
        "fortimail_time" => "%{[fortimail][time]}"
      }
    }

    ruby {
      code => '
        require "time"
        if event.get("fortimail_date") && event.get("fortimail_time")
          datetime_str = event.get("fortimail_date").to_s + "T" + event.get("fortimail_time").to_s
          begin
            event.set("@timestamp", LogStash::Timestamp.new(Time.parse(datetime_str)))
          rescue => e
            event.tag("timestamp_parse_failure")
          end
        end
      '
    }

    ########################
    # ğŸ§  ECS Normalisation #
    ########################

    mutate {
      rename => {
        "[fortimail][client_ip]"   => "source.ip"
        "[fortimail][client_name]" => "source.domain"
        "[fortimail][device_id]"   => "host.name"
        "[fortimail][dst_ip]"      => "destination.ip"
        "[fortimail][from]"        => "source.user.email"
        "[fortimail][to]"          => "destination.user.email"
        "[fortimail][subject]"     => "email.subject"
        "[fortimail][msg]"         => "message"
        "[fortimail][log_id]"      => "event.id"
        "[fortimail][session_id]"  => "event.session"
        "[fortimail][type]"        => "event.type"
        "[fortimail][pri]"         => "log.syslog.priority"
      }

      add_field => {
        "event.kind"       => "event"
        "event.module"     => "fortimail"
        "observer.vendor"  => "Fortinet"
        "observer.product" => "FortiMail"
      }
    }

    # Classification de lâ€™Ã©vÃ©nement
    if [event.type] == "spam" {
      mutate {
        replace => {
          "event.category" => "email"
          "event.outcome"  => "success"
          "event.action"   => "email_marked_as_spam"
        }
        add_tag => ["fortimail_spam"]
      }
    } else if [event.type] == "statistics" {
      mutate {
        replace => {
          "event.category" => "email"
          "event.action"   => "email_statistics"
        }
        add_tag => ["fortimail_statistics"]
      }
    } else {
      mutate {
        replace => {
          "event.category" => "email"
          "event.action"   => "unknown"
        }
        add_tag => ["fortimail_unknown"]
      }
    }

    # Nettoyage final
    mutate {
      remove_field => [
        "message", "fortimail_message", "fortimail_date", "fortimail_time",
        "date", "time", "host", "agent", "input", "ecs", "log", "fields"
      ]
    }
  } else {
    drop {}
  }
}

output {
  elasticsearch {
    hosts => ["http://192.168.56.101:9200"]
    index => "fortimail-%{+YYYY.MM.dd}"
  }

  file {
    path => "/tmp/fortimail_parsed.log"
    codec => rubydebug
  }
}
